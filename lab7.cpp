class Solution {
public:
    int minPatches(vector<int>& nums, int n) {
        // подсчет памяти:
        // - используем несколько переменных: ans, i, miss.
        // - память: O(1), так как не используем дополнительных структур данных.

        // асимптотика:
        // - временная сложность: O(m + log n), где m — длина nums.
        //   - проходим по nums один раз (O(m)).
        //   - каждое удвоение miss занимает O(log n) шагов.
        // - пространственная сложность: O(1).

        int ans = 0; // количество добавленных патчей
        int i = 0;   // индекс для обхода nums
        long miss = 1; // минимальное число, которое мы не можем покрыть

        // пока miss <= n, продолжаем искать числа, которые нужно добавить
        while (miss <= n) {
            if (i < nums.size() && nums[i] <= miss) {
                // если текущее число nums[i] <= miss, добавляем его к диапазону
                // теперь мы можем покрыть все числа до miss + nums[i] - 1
                miss += nums[i++];
            } else {
                // если nums[i] > miss или nums закончились, добавляем miss
                // это увеличивает диапазон покрытия до 2 * miss
                miss += miss;
                ++ans; // увеличиваем счетчик добавленных патчей
            }
        }

        return ans;
    }
};
